package phases

import (
	"github.com/pkg/errors"
	rbac "k8s.io/api/rbac/v1"
	kuberuntime "k8s.io/apimachinery/pkg/runtime"
	clientset "k8s.io/client-go/kubernetes"
	clientsetscheme "k8s.io/client-go/kubernetes/scheme"
	"k8s.io/kubernetes/cmd/kubeadm/app/cmd/phases/workflow"
	cmdutil "k8s.io/kubernetes/cmd/kubeadm/app/cmd/util"
	kubeadmconstants "k8s.io/kubernetes/cmd/kubeadm/app/constants"
	pash "k8s.io/kubernetes/cmd/kubeadm/app/phases/apiserverha"
	"k8s.io/kubernetes/cmd/kubeadm/app/util/apiclient"
	"net"
	"strconv"
)

// TODO 需要修改，并增加说明。
var apiserverHaPlaneExample = cmdutil.Examples(`
		# Generates all static Pod manifest files for control plane components,
		# functionally equivalent to what is generated by kubeadm init.
		kubeadm init phase control-plane all

		# Generates all static Pod manifest files using options read from a configuration file.
		kubeadm init phase control-plane all --config config.yaml
		`)

const ApiserverHaClusterRole = `
apiVersion: rbac.authorization.k8s.io/v1
kind: ClusterRole
metadata:
  name: apiserverha
rules:
- apiGroups:
  - ""
  resources:
  - endpoints
  verbs:
  - get
  - list
  - watch
`

const ApiserverHaClusterRoleBinding = `
apiVersion: rbac.authorization.k8s.io/v1
kind: ClusterRoleBinding
metadata:
  name: apiserverha
roleRef:
  apiGroup: rbac.authorization.k8s.io
  kind: ClusterRole
  name: apiserverha
subjects:
- apiGroup: rbac.authorization.k8s.io
  kind: User
  name: apiserver-ha
`

func NewApiserverHaPreflightPhase() workflow.Phase {
	phase := workflow.Phase{
		Name:  "apiserver-ha-preflight",
		Short: "open the apiserver ha mod, and write the ipvs into the system, ready for all conponent run. ",
		Long:  `open the apiserver ha mod, and write the ipvs into the system, ready for all conponent run.`,
		Phases: []workflow.Phase{
			{
				Name:           "apiserver-ha-preflight",
				Short:          "check and write the ipvs into the system",
				Example:        apiserverHaPlaneExample,
				RunAllSiblings: true,
			},
		},
		Run: RunApiserverHaPreflightPhase,
	}
	return phase
}

func NewApiserverHaPhase() workflow.Phase {
	phase := workflow.Phase{
		Name:  "apiserver-ha",
		Short: "open the apiserver ha mod, implements the master stack ha.",
		Long: `open the apiserver ha mod, implements the master stack ha. apiserver-ha will 
		use the endpoints is kubernetes implements the master apiserver ha.`,
		Phases: []workflow.Phase{
			{
				Name:  "apiserver-ha",
				Short: "Generate apiserver-ha static Pod manifest files and the kubeconf file",
				// InheritFlags:   getControlPlanePhaseFlags("all"),
				Example:        apiserverHaPlaneExample,
				RunAllSiblings: true,
			},
		},
		Run: RunApiserverHaPhase,
	}
	return phase
}

func RunApiserverHaPreflightPhase(c workflow.RunData) error {
	data := c.(InitData)

	if !data.Cfg().ClusterConfiguration.ApiserverHA.Enable {
		return nil
	}

	// todo check the apiserver work on the ipvs mode

	// write the ipvs into the system
	controlPlaneEndpoint, err := pash.GetApiserverHaControlPlan(data.Cfg().Networking.ServiceSubnet,
		data.Cfg().FeatureGates)
	if err != nil {
		return errors.Wrap(err, "Create the apiserver-ha controlPlaneEndpoint fails")
	}

	err = pash.WriteIpvs(controlPlaneEndpoint, net.JoinHostPort(data.Cfg().LocalAPIEndpoint.AdvertiseAddress,
		strconv.Itoa(int(data.Cfg().LocalAPIEndpoint.BindPort))))

	if err != nil {
		return errors.Wrap(err, "apiserver write the ipvs fails.")
	}

	ip, _, err := net.SplitHostPort(controlPlaneEndpoint)
	if err != nil {
		return errors.Wrap(err, "apiserver write the ipvs fails.")
	}
	err = pash.CreateDev(ip)
	if err != nil {
		return err
	}

	return nil
}

func RunApiserverHaPhase(c workflow.RunData) error {
	data := c.(InitData)

	if data.Cfg().ClusterConfiguration.ApiserverHA.Enable == false {
		// if not open the apiserver-ha，then skip
		return nil
	}

	// create the client for create the clusterrolebinding
	client, err := data.Client()
	if err != nil {
		return errors.Errorf("get client false, %v", err)
	}

	err = craeteApiserverHaUserRoleAndBinding(client)
	if err != nil {
		return errors.Errorf("create the apiserverHaUserRoleBinding false, %v", err)
	}

	apiserverRealEndpoint := net.JoinHostPort(data.Cfg().LocalAPIEndpoint.AdvertiseAddress,
		strconv.Itoa(int(data.Cfg().LocalAPIEndpoint.BindPort)))

	remoteLoader := &pash.LocalLoader{
		CertificatesDir:      data.Cfg().CertificatesDir,
		CACertAndKeyBaseName: kubeadmconstants.CACertAndKeyBaseName,
	}

	err = pash.BuildApiserverHaNode(data.Cfg().ClusterName, data.Cfg().ControlPlaneEndpoint, apiserverRealEndpoint,
		data.Cfg().Networking.ServiceSubnet, data.Cfg().ClusterConfiguration.ApiserverHA.Image, remoteLoader)
	err = craeteApiserverHaUserRoleAndBinding(client)
	if err != nil {
		return errors.Errorf("create apiserverhs node fails, %v", err)
	}

	return nil
}

func craeteApiserverHaUserRoleAndBinding(client clientset.Interface) error {

	// load the rolebinding yaml
	apiserverHaClusterRole := &rbac.ClusterRole{}
	if err := kuberuntime.DecodeInto(clientsetscheme.Codecs.UniversalDecoder(), []byte(ApiserverHaClusterRole), apiserverHaClusterRole); err != nil {
		return errors.Wrapf(err, "%s ClusterRole create parser fails", ApiserverHaClusterRole)
	}

	if err := apiclient.CreateOrUpdateClusterRole(client, apiserverHaClusterRole); err != nil {
		return err
	}

	// load the rolebinding yaml
	apiserverHaClusterRolesBinding := &rbac.ClusterRoleBinding{}
	if err := kuberuntime.DecodeInto(clientsetscheme.Codecs.UniversalDecoder(), []byte(ApiserverHaClusterRoleBinding), apiserverHaClusterRolesBinding); err != nil {
		return errors.Wrapf(err, "%s ClusterRoleBinding", ApiserverHaClusterRoleBinding)
	}
	// Create the Clusterrolebindings for CoreDNS or update it in case it already exists
	if err := apiclient.CreateOrUpdateClusterRoleBinding(client, apiserverHaClusterRolesBinding); err != nil {
		return err
	}

	return nil
}
